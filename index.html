<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Panoramic Game Demo</title>
    <script type="module">
        import { inject } from 'https://cdn.jsdelivr.net/npm/@vercel/analytics@1/dist/index.js';
        inject();
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        Controls: WASD to move | Mouse/Touch to look around<br>
        FPS: <span id="fps">0</span>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ========================================
        // Shader Definitions
        // ========================================

        // Vertex shader for cylindrical projection
        const cylinderVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment shader for cylindrical cubemap projection
        const cylinderFragmentShader = `
            uniform samplerCube cubemap;
            varying vec2 vUv;

            void main() {
                // Convert horizontal UV (0-1) to angle around Y axis (0-2π)
                float angle = vUv.x * 2.0 * 3.14159265359;

                // Convert vertical UV to elevation angle
                // Map from 0-1 to a limited vertical range to avoid pole distortion
                float verticalAngle = (vUv.y - 0.5) * 0.8; // ±0.4 range, flattened

                // Create direction vector for sampling cubemap
                vec3 direction = vec3(
                    sin(angle),
                    verticalAngle,
                    cos(angle)
                );

                direction = normalize(direction);

                // Sample the cubemap
                vec4 color = textureCube(cubemap, direction);

                gl_FragColor = color;
            }
        `;

        // ========================================
        // Scene Setup
        // ========================================

        let camera, topCamera, cubeCamera, scene, renderer;
        let cubeRenderTarget;
        let cylinderMesh, cylinderScene, cylinderCamera;
        let player = {
            position: new THREE.Vector3(0, 1.6, 0),
            rotation: { yaw: 0, pitch: 0 },
            velocity: new THREE.Vector3()
        };

        let keys = {};
        let mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, down: false };
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = performance.now();

        function initScene() {
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; // We'll manually clear for dual viewport
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding; // Proper color space
            document.body.appendChild(renderer.domElement);

            // Main scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa8daff); // Lighter, prettier sky blue
            scene.fog = new THREE.Fog(0xa8daff, 25, 55);

            // Lighting - improved for better visuals
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Add a warm fill light
            const fillLight = new THREE.DirectionalLight(0xffa95c, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // Ground plane - improved with better grass color
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a9d4a,
                roughness: 0.9,
                metalness: 0.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Function to create a house (cube with pyramid roof)
            function createHouse(size) {
                const house = new THREE.Group();

                // House colors - more sophisticated palette
                const wallColors = [
                    0xffb3ba, 0xbae1ff, 0xffffba, 0xbaffc9, 0xffdfba,
                    0xe0bbe4, 0xffd8be, 0xc7ceea, 0xb5ead7, 0xffc8dd,
                    0xa2d2ff, 0xffafcc, 0xcdb4db, 0xffc8b4, 0xbde0fe
                ];
                const roofColors = [
                    0x8b4513, 0xa0522d, 0xd2691e, 0xcd853f, 0xe74c3c,
                    0xc0392b, 0x95a5a6, 0x7f8c8d, 0x2c3e50, 0x8e44ad
                ];

                // Base (walls)
                const baseHeight = size * 1.2; // Taller proportions
                const baseGeo = new THREE.BoxGeometry(size, baseHeight, size);
                const baseMat = new THREE.MeshStandardMaterial({
                    color: wallColors[Math.floor(Math.random() * wallColors.length)],
                    roughness: 0.7,
                    metalness: 0.0
                });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = baseHeight / 2;
                base.castShadow = true;
                base.receiveShadow = true;
                house.add(base);

                // Door
                const doorGeo = new THREE.BoxGeometry(size * 0.3, size * 0.5, 0.05);
                const doorMat = new THREE.MeshStandardMaterial({
                    color: 0x654321,
                    roughness: 0.8
                });
                const door = new THREE.Mesh(doorGeo, doorMat);
                door.position.set(0, size * 0.25, size / 2 + 0.01);
                door.castShadow = true;
                house.add(door);

                // Windows - 2 on front
                const windowGeo = new THREE.BoxGeometry(size * 0.2, size * 0.2, 0.05);
                const windowMat = new THREE.MeshStandardMaterial({
                    color: 0x87ceeb,
                    roughness: 0.1,
                    metalness: 0.5,
                    emissive: 0x4a90e2,
                    emissiveIntensity: 0.2
                });

                const window1 = new THREE.Mesh(windowGeo, windowMat);
                window1.position.set(-size * 0.25, baseHeight * 0.6, size / 2 + 0.01);
                house.add(window1);

                const window2 = new THREE.Mesh(windowGeo, windowMat);
                window2.position.set(size * 0.25, baseHeight * 0.6, size / 2 + 0.01);
                house.add(window2);

                // Side windows
                const window3 = new THREE.Mesh(windowGeo, windowMat);
                window3.position.set(size / 2 + 0.01, baseHeight * 0.6, 0);
                window3.rotation.y = Math.PI / 2; // Rotate 90° to align with side wall
                house.add(window3);

                const window4 = new THREE.Mesh(windowGeo, windowMat);
                window4.position.set(-size / 2 - 0.01, baseHeight * 0.6, 0);
                window4.rotation.y = Math.PI / 2; // Rotate 90° to align with side wall
                house.add(window4);

                // Roof (pyramid)
                const roofHeight = size * 0.7;
                const roofGeo = new THREE.ConeGeometry(size * 0.75, roofHeight, 4);
                const roofMat = new THREE.MeshStandardMaterial({
                    color: roofColors[Math.floor(Math.random() * roofColors.length)],
                    roughness: 0.8,
                    metalness: 0.1
                });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = baseHeight + roofHeight / 2;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                house.add(roof);

                return house;
            }

            // Function to create a stick figure person
            function createPerson() {
                const person = new THREE.Group();

                // Better color palette for people
                const skinColors = [0xffdab9, 0xf5cba7, 0xd2b48c, 0xcd9575];
                const shirtColors = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf7b731, 0x5f27cd,
                    0xff9ff3, 0xfeca57, 0x48dbfb, 0x1dd1a1, 0xee5a6f
                ];
                const pantsColors = [0x2c3e50, 0x34495e, 0x5d6d7e, 0x1c2833, 0x566573];

                const skinColor = skinColors[Math.floor(Math.random() * skinColors.length)];
                const shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];
                const pantsColor = pantsColors[Math.floor(Math.random() * pantsColors.length)];

                const skinMat = new THREE.MeshStandardMaterial({
                    color: skinColor,
                    roughness: 0.7,
                    metalness: 0.0
                });

                const shirtMat = new THREE.MeshStandardMaterial({
                    color: shirtColor,
                    roughness: 0.8,
                    metalness: 0.1
                });

                const pantsMat = new THREE.MeshStandardMaterial({
                    color: pantsColor,
                    roughness: 0.9,
                    metalness: 0.0
                });

                // Head
                const headGeo = new THREE.SphereGeometry(0.18, 16, 16);
                const head = new THREE.Mesh(headGeo, skinMat);
                head.position.y = 1.5;
                head.castShadow = true;
                person.add(head);

                // Body (shirt)
                const bodyGeo = new THREE.CylinderGeometry(0.12, 0.14, 0.7, 8);
                const body = new THREE.Mesh(bodyGeo, shirtMat);
                body.position.y = 0.9;
                body.castShadow = true;
                person.add(body);

                // Left Arm
                const armGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.6, 8);
                const leftArm = new THREE.Mesh(armGeo, shirtMat);
                leftArm.position.set(-0.18, 1.0, 0);
                leftArm.rotation.z = Math.PI / 8;
                leftArm.castShadow = true;
                person.add(leftArm);

                // Right Arm
                const rightArm = new THREE.Mesh(armGeo, shirtMat);
                rightArm.position.set(0.18, 1.0, 0);
                rightArm.rotation.z = -Math.PI / 8;
                rightArm.castShadow = true;
                person.add(rightArm);

                // Left Leg (pants)
                const legGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.6, 8);
                const leftLeg = new THREE.Mesh(legGeo, pantsMat);
                leftLeg.position.set(-0.08, 0.3, 0);
                leftLeg.castShadow = true;
                person.add(leftLeg);

                // Right Leg (pants)
                const rightLeg = new THREE.Mesh(legGeo, pantsMat);
                rightLeg.position.set(0.08, 0.3, 0);
                rightLeg.castShadow = true;
                person.add(rightLeg);

                return person;
            }

            // Add houses to the scene
            for (let i = 0; i < 20; i++) {
                const houseSize = Math.random() * 2 + 1.5; // Size between 1.5 and 3.5
                const house = createHouse(houseSize);
                house.position.set(
                    (Math.random() - 0.5) * 40,
                    0,
                    (Math.random() - 0.5) * 40
                );
                house.rotation.y = Math.random() * Math.PI * 2;
                scene.add(house);
            }

            // Add people to the scene
            for (let i = 0; i < 30; i++) {
                const person = createPerson();
                person.position.set(
                    (Math.random() - 0.5) * 40,
                    0,
                    (Math.random() - 0.5) * 40
                );
                person.rotation.y = Math.random() * Math.PI * 2;
                scene.add(person);
            }

            // Top viewport camera (standard first-person view)
            topCamera = new THREE.PerspectiveCamera(
                75, // FOV
                window.innerWidth / (window.innerHeight / 2), // Aspect ratio for half viewport
                0.1,
                100
            );

            // Cubemap render target for 360° capture
            cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter
                // Keep in linear space for shader sampling
            });

            // Cube camera for omnidirectional rendering
            cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);

            // Cylinder scene and camera for panorama display
            cylinderScene = new THREE.Scene();
            cylinderScene.background = new THREE.Color(0xa8daff); // Match main scene sky
            cylinderCamera = new THREE.OrthographicCamera(-4, 4, 1, -1, 0.1, 10);
            cylinderCamera.position.z = 1;

            // Panorama plane - wide aspect ratio for 360° view
            const debugGeometry = new THREE.PlaneGeometry(8, 2);

            // Debug shader to visualize cubemap
            const debugVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const debugFragmentShader = `
                uniform samplerCube cubemap;
                uniform float playerYaw;
                varying vec2 vUv;

                void main() {
                    // Cylindrical projection: warp cubemap into seamless 360° panorama

                    // Convert horizontal UV (0-1) to angle around Y axis (0 to 2π)
                    // Add player yaw to rotate panorama with player's view
                    float angle = (1.0 - vUv.x) * 2.0 * 3.14159265359 + playerYaw; // Flipped horizontally + yaw rotation

                    // Convert vertical UV to elevation
                    // Map from 0-1 to a limited vertical range to avoid pole distortion
                    float verticalAngle = (vUv.y - 0.5) * 1.2; // Adjust range for better coverage

                    // Create direction vector for sampling cubemap
                    // This creates a cylinder around the Y axis
                    vec3 direction = vec3(
                        sin(angle),           // X component varies with angle
                        verticalAngle,        // Y component for vertical look
                        cos(angle)            // Z component varies with angle
                    );

                    direction = normalize(direction);

                    // Sample the cubemap at this direction
                    vec4 color = textureCube(cubemap, direction);

                    // Brightness adjustment to match main camera
                    // Slightly boost since cubemap rendering can be darker
                    color.rgb *= 1.8;

                    gl_FragColor = color;
                }
            `;

            const debugMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    cubemap: { value: cubeRenderTarget.texture },
                    playerYaw: { value: 0.0 }
                },
                vertexShader: debugVertexShader,
                fragmentShader: debugFragmentShader
            });

            cylinderMesh = new THREE.Mesh(debugGeometry, debugMaterial);
            cylinderScene.add(cylinderMesh);
        }

        // ========================================
        // Input Handling
        // ========================================

        function initInput() {
            // Keyboard input
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Mouse input
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouse.down = true;
                renderer.domElement.requestPointerLock();
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouse.down = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === renderer.domElement) {
                    mouse.deltaX = e.movementX || 0;
                    mouse.deltaY = e.movementY || 0;
                }
            });

            // Touch input
            let lastTouchX = 0;
            let lastTouchY = 0;

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length > 0) {
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    mouse.down = true;
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouse.deltaX = (touch.clientX - lastTouchX) * 0.5;
                    mouse.deltaY = (touch.clientY - lastTouchY) * 0.5;
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                mouse.down = false;
                mouse.deltaX = 0;
                mouse.deltaY = 0;
            });

            // Prevent context menu on right click
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setSize(width, height);

            // Update top camera aspect ratio (for half viewport)
            topCamera.aspect = width / (height / 2);
            topCamera.updateProjectionMatrix();

            // Update cylinder camera for bottom viewport
            const aspect = width / (height / 2);
            // Show full panorama width (8 units = -4 to 4)
            const horizontalSize = 4;
            // Adjust vertical to maintain aspect ratio
            const verticalSize = horizontalSize / aspect;

            cylinderCamera.left = -horizontalSize;
            cylinderCamera.right = horizontalSize;
            cylinderCamera.top = verticalSize;
            cylinderCamera.bottom = -verticalSize;
            cylinderCamera.updateProjectionMatrix();
        }

        // ========================================
        // Update Logic
        // ========================================

        function updatePlayer(deltaTime) {
            const moveSpeed = 5.0 * deltaTime;
            const lookSensitivity = 0.002;

            // Update rotation from mouse/touch input
            player.rotation.yaw -= mouse.deltaX * lookSensitivity;
            player.rotation.pitch -= mouse.deltaY * lookSensitivity;

            // Clamp pitch to prevent camera flip
            player.rotation.pitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, player.rotation.pitch));

            // Reset mouse delta
            mouse.deltaX = 0;
            mouse.deltaY = 0;

            // Calculate forward and right vectors based on yaw
            // Forward direction matches Three.js camera orientation
            const forward = new THREE.Vector3(
                -Math.sin(player.rotation.yaw),
                0,
                -Math.cos(player.rotation.yaw)
            );
            const right = new THREE.Vector3(
                -Math.sin(player.rotation.yaw + Math.PI / 2),
                0,
                -Math.cos(player.rotation.yaw + Math.PI / 2)
            );

            // WASD movement
            player.velocity.set(0, 0, 0);

            if (keys['KeyW']) {
                player.velocity.add(forward);
            }
            if (keys['KeyS']) {
                player.velocity.sub(forward);
            }
            if (keys['KeyA']) {
                player.velocity.add(right);
            }
            if (keys['KeyD']) {
                player.velocity.sub(right);
            }

            // Normalize and apply movement
            if (player.velocity.length() > 0) {
                player.velocity.normalize();
                player.position.add(player.velocity.multiplyScalar(moveSpeed));
            }

            // Update top camera
            topCamera.position.copy(player.position);
            topCamera.rotation.order = 'YXZ';
            topCamera.rotation.y = player.rotation.yaw;
            //topCamera.rotation.x = player.rotation.pitch;

            // Update cube camera position
            cubeCamera.position.copy(player.position);
        }

        // ========================================
        // Render Loop
        // ========================================

        let framesSinceLastCubemapUpdate = 0;
        const cubemapUpdateInterval = 2; // Update cubemap every N frames for performance

        function animate() {
            requestAnimationFrame(animate);

            // Calculate delta time
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Update player and cameras
            updatePlayer(deltaTime);

            // Update cubemap (not every frame for performance)
            if (framesSinceLastCubemapUpdate >= cubemapUpdateInterval) {
                cubeCamera.update(renderer, scene);
                framesSinceLastCubemapUpdate = 0;
            }
            framesSinceLastCubemapUpdate++;

            // ===== TOP VIEWPORT: Standard first-person view =====
            const width = window.innerWidth;
            const height = window.innerHeight;
            const halfHeight = Math.floor(height / 2);

            renderer.setViewport(0, halfHeight, width, height - halfHeight);
            renderer.setScissor(0, halfHeight, width, height - halfHeight);
            renderer.setScissorTest(true);
            renderer.clear();  // Clear only this viewport
            renderer.render(scene, topCamera);

            // ===== BOTTOM VIEWPORT: 360° panorama =====
            // Update panorama rotation based on player yaw
            cylinderMesh.material.uniforms.playerYaw.value = player.rotation.yaw;

            renderer.setViewport(0, 0, width, halfHeight);
            renderer.setScissor(0, 0, width, halfHeight);
            renderer.setScissorTest(true);
            renderer.clear();  // Clear only this viewport
            renderer.render(cylinderScene, cylinderCamera);

            // Disable scissor test
            renderer.setScissorTest(false);
        }

        // ========================================
        // Initialize and Start
        // ========================================

        initScene();
        initInput();
        onWindowResize(); // Set initial viewport sizes
        animate();

    </script>
</body>
</html>
