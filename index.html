<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Panoramic Game Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        Controls: WASD to move | Mouse/Touch to look around<br>
        FPS: <span id="fps">0</span>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ========================================
        // Shader Definitions
        // ========================================

        // Vertex shader for cylindrical projection
        const cylinderVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment shader for cylindrical cubemap projection
        const cylinderFragmentShader = `
            uniform samplerCube cubemap;
            varying vec2 vUv;

            void main() {
                // Convert horizontal UV (0-1) to angle around Y axis (0-2π)
                float angle = vUv.x * 2.0 * 3.14159265359;

                // Convert vertical UV to elevation angle
                // Map from 0-1 to a limited vertical range to avoid pole distortion
                float verticalAngle = (vUv.y - 0.5) * 0.8; // ±0.4 range, flattened

                // Create direction vector for sampling cubemap
                vec3 direction = vec3(
                    sin(angle),
                    verticalAngle,
                    cos(angle)
                );

                direction = normalize(direction);

                // Sample the cubemap
                vec4 color = textureCube(cubemap, direction);

                gl_FragColor = color;
            }
        `;

        // ========================================
        // Scene Setup
        // ========================================

        let camera, topCamera, cubeCamera, scene, renderer;
        let cubeRenderTarget;
        let cylinderMesh, cylinderScene, cylinderCamera;
        let player = {
            position: new THREE.Vector3(0, 1.6, 0),
            rotation: { yaw: 0, pitch: 0 },
            velocity: new THREE.Vector3()
        };

        let keys = {};
        let mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, down: false };
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = performance.now();

        function initScene() {
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; // We'll manually clear for dual viewport
            document.body.appendChild(renderer.domElement);

            // Main scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 20, 50);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a8c3a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Function to create a house (cube with pyramid roof)
            function createHouse(size) {
                const house = new THREE.Group();

                // House colors - vibrant and varied
                const wallColors = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf7b731, 0x5f27cd,
                    0x00d2d3, 0xff9ff3, 0xfeca57, 0x48dbfb, 0xff6348,
                    0x1dd1a1, 0xee5a6f, 0xc44569, 0x786fa6, 0xf8a5c2,
                    0xfa8231, 0x6c5ce7, 0xa29bfe, 0xfd79a8, 0xfdcb6e
                ];
                const roofColors = [
                    0x8b4513, 0xa0522d, 0x654321, 0x704214, 0xe74c3c,
                    0xc0392b, 0x7f8c8d, 0x34495e, 0x2c3e50, 0x8e44ad
                ];

                // Base (walls)
                const baseHeight = size;
                const baseGeo = new THREE.BoxGeometry(size, baseHeight, size);
                const baseMat = new THREE.MeshStandardMaterial({
                    color: wallColors[Math.floor(Math.random() * wallColors.length)],
                    roughness: 0.8,
                    metalness: 0.1
                });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = baseHeight / 2;
                base.castShadow = true;
                house.add(base);

                // Roof (pyramid)
                const roofHeight = size * 0.6;
                const roofGeo = new THREE.ConeGeometry(size * 0.7, roofHeight, 4);
                const roofMat = new THREE.MeshStandardMaterial({
                    color: roofColors[Math.floor(Math.random() * roofColors.length)],
                    roughness: 0.7,
                    metalness: 0.2
                });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = baseHeight + roofHeight / 2;
                roof.rotation.y = Math.PI / 4; // Rotate 45° for pyramid alignment
                roof.castShadow = true;
                house.add(roof);

                return house;
            }

            // Function to create a stick figure person
            function createPerson() {
                const person = new THREE.Group();
                const personColor = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf7b731, 0x5f27cd,
                    0xff9ff3, 0xfeca57, 0x48dbfb, 0x1dd1a1
                ][Math.floor(Math.random() * 9)];

                const material = new THREE.MeshStandardMaterial({
                    color: personColor,
                    roughness: 0.6,
                    metalness: 0.3
                });

                // Head
                const headGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const head = new THREE.Mesh(headGeo, material);
                head.position.y = 1.3;
                head.castShadow = true;
                person.add(head);

                // Body
                const bodyGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8);
                const body = new THREE.Mesh(bodyGeo, material);
                body.position.y = 0.8;
                body.castShadow = true;
                person.add(body);

                // Left Arm
                const armGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8);
                const leftArm = new THREE.Mesh(armGeo, material);
                leftArm.position.set(-0.15, 0.9, 0);
                leftArm.rotation.z = Math.PI / 6;
                leftArm.castShadow = true;
                person.add(leftArm);

                // Right Arm
                const rightArm = new THREE.Mesh(armGeo, material);
                rightArm.position.set(0.15, 0.9, 0);
                rightArm.rotation.z = -Math.PI / 6;
                rightArm.castShadow = true;
                person.add(rightArm);

                // Left Leg
                const legGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8);
                const leftLeg = new THREE.Mesh(legGeo, material);
                leftLeg.position.set(-0.08, 0.25, 0);
                leftLeg.castShadow = true;
                person.add(leftLeg);

                // Right Leg
                const rightLeg = new THREE.Mesh(legGeo, material);
                rightLeg.position.set(0.08, 0.25, 0);
                rightLeg.castShadow = true;
                person.add(rightLeg);

                return person;
            }

            // Add houses to the scene
            for (let i = 0; i < 20; i++) {
                const houseSize = Math.random() * 2 + 1.5; // Size between 1.5 and 3.5
                const house = createHouse(houseSize);
                house.position.set(
                    (Math.random() - 0.5) * 40,
                    0,
                    (Math.random() - 0.5) * 40
                );
                house.rotation.y = Math.random() * Math.PI * 2;
                scene.add(house);
            }

            // Add people to the scene
            for (let i = 0; i < 30; i++) {
                const person = createPerson();
                person.position.set(
                    (Math.random() - 0.5) * 40,
                    0,
                    (Math.random() - 0.5) * 40
                );
                person.rotation.y = Math.random() * Math.PI * 2;
                scene.add(person);
            }

            // Top viewport camera (standard first-person view)
            topCamera = new THREE.PerspectiveCamera(
                75, // FOV
                window.innerWidth / (window.innerHeight / 2), // Aspect ratio for half viewport
                0.1,
                100
            );

            // Cubemap render target for 360° capture
            cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter
            });

            // Cube camera for omnidirectional rendering
            cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);

            // Cylinder scene and camera for panorama display
            cylinderScene = new THREE.Scene();
            cylinderCamera = new THREE.OrthographicCamera(-4, 4, 1, -1, 0.1, 10);
            cylinderCamera.position.z = 1;

            // Panorama plane - wide aspect ratio for 360° view
            const debugGeometry = new THREE.PlaneGeometry(8, 2);

            // Debug shader to visualize cubemap
            const debugVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const debugFragmentShader = `
                uniform samplerCube cubemap;
                uniform float playerYaw;
                varying vec2 vUv;

                void main() {
                    // Cylindrical projection: warp cubemap into seamless 360° panorama

                    // Convert horizontal UV (0-1) to angle around Y axis (0 to 2π)
                    // Add player yaw to rotate panorama with player's view
                    float angle = (1.0 - vUv.x) * 2.0 * 3.14159265359 + playerYaw; // Flipped horizontally + yaw rotation

                    // Convert vertical UV to elevation
                    // Map from 0-1 to a limited vertical range to avoid pole distortion
                    float verticalAngle = (vUv.y - 0.5) * 1.2; // Adjust range for better coverage

                    // Create direction vector for sampling cubemap
                    // This creates a cylinder around the Y axis
                    vec3 direction = vec3(
                        sin(angle),           // X component varies with angle
                        verticalAngle,        // Y component for vertical look
                        cos(angle)            // Z component varies with angle
                    );

                    direction = normalize(direction);

                    // Sample the cubemap at this direction
                    vec4 color = textureCube(cubemap, direction);

                    // Brighten the output to match the top viewport
                    color.rgb *= 3.0;

                    gl_FragColor = color;
                }
            `;

            const debugMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    cubemap: { value: cubeRenderTarget.texture },
                    playerYaw: { value: 0.0 }
                },
                vertexShader: debugVertexShader,
                fragmentShader: debugFragmentShader
            });

            cylinderMesh = new THREE.Mesh(debugGeometry, debugMaterial);
            cylinderScene.add(cylinderMesh);
        }

        // ========================================
        // Input Handling
        // ========================================

        function initInput() {
            // Keyboard input
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Mouse input
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouse.down = true;
                renderer.domElement.requestPointerLock();
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouse.down = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === renderer.domElement) {
                    mouse.deltaX = e.movementX || 0;
                    mouse.deltaY = e.movementY || 0;
                }
            });

            // Touch input
            let lastTouchX = 0;
            let lastTouchY = 0;

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length > 0) {
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    mouse.down = true;
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouse.deltaX = (touch.clientX - lastTouchX) * 0.5;
                    mouse.deltaY = (touch.clientY - lastTouchY) * 0.5;
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                mouse.down = false;
                mouse.deltaX = 0;
                mouse.deltaY = 0;
            });

            // Prevent context menu on right click
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setSize(width, height);

            // Update top camera aspect ratio (for half viewport)
            topCamera.aspect = width / (height / 2);
            topCamera.updateProjectionMatrix();

            // Update cylinder camera for bottom viewport
            const aspect = width / (height / 2);
            // Show full panorama width (8 units = -4 to 4)
            const horizontalSize = 4;
            // Adjust vertical to maintain aspect ratio
            const verticalSize = horizontalSize / aspect;

            cylinderCamera.left = -horizontalSize;
            cylinderCamera.right = horizontalSize;
            cylinderCamera.top = verticalSize;
            cylinderCamera.bottom = -verticalSize;
            cylinderCamera.updateProjectionMatrix();
        }

        // ========================================
        // Update Logic
        // ========================================

        function updatePlayer(deltaTime) {
            const moveSpeed = 5.0 * deltaTime;
            const lookSensitivity = 0.002;

            // Update rotation from mouse/touch input
            player.rotation.yaw -= mouse.deltaX * lookSensitivity;
            player.rotation.pitch -= mouse.deltaY * lookSensitivity;

            // Clamp pitch to prevent camera flip
            player.rotation.pitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, player.rotation.pitch));

            // Reset mouse delta
            mouse.deltaX = 0;
            mouse.deltaY = 0;

            // Calculate forward and right vectors based on yaw
            // Forward direction matches Three.js camera orientation
            const forward = new THREE.Vector3(
                -Math.sin(player.rotation.yaw),
                0,
                -Math.cos(player.rotation.yaw)
            );
            const right = new THREE.Vector3(
                -Math.sin(player.rotation.yaw + Math.PI / 2),
                0,
                -Math.cos(player.rotation.yaw + Math.PI / 2)
            );

            // WASD movement
            player.velocity.set(0, 0, 0);

            if (keys['KeyW']) {
                player.velocity.add(forward);
            }
            if (keys['KeyS']) {
                player.velocity.sub(forward);
            }
            if (keys['KeyA']) {
                player.velocity.add(right);
            }
            if (keys['KeyD']) {
                player.velocity.sub(right);
            }

            // Normalize and apply movement
            if (player.velocity.length() > 0) {
                player.velocity.normalize();
                player.position.add(player.velocity.multiplyScalar(moveSpeed));
            }

            // Update top camera
            topCamera.position.copy(player.position);
            topCamera.rotation.order = 'YXZ';
            topCamera.rotation.y = player.rotation.yaw;
            //topCamera.rotation.x = player.rotation.pitch;

            // Update cube camera position
            cubeCamera.position.copy(player.position);
        }

        // ========================================
        // Render Loop
        // ========================================

        let framesSinceLastCubemapUpdate = 0;
        const cubemapUpdateInterval = 2; // Update cubemap every N frames for performance

        function animate() {
            requestAnimationFrame(animate);

            // Calculate delta time
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Update player and cameras
            updatePlayer(deltaTime);

            // Update cubemap (not every frame for performance)
            if (framesSinceLastCubemapUpdate >= cubemapUpdateInterval) {
                cubeCamera.update(renderer, scene);
                framesSinceLastCubemapUpdate = 0;
            }
            framesSinceLastCubemapUpdate++;

            // Clear the entire canvas
            renderer.clear();

            // ===== TOP VIEWPORT: Standard first-person view =====
            const width = window.innerWidth;
            const height = window.innerHeight;
            const halfHeight = Math.floor(height / 2);
            const overlap = 10; // Small overlap to prevent flickering line

            renderer.setViewport(0, halfHeight, width, height - halfHeight);
            renderer.setScissor(0, halfHeight, width, height - halfHeight);
            renderer.setScissorTest(true);
            renderer.render(scene, topCamera);

            // ===== BOTTOM VIEWPORT: 360° panorama =====
            // Update panorama rotation based on player yaw
            cylinderMesh.material.uniforms.playerYaw.value = player.rotation.yaw;

            renderer.setViewport(0, 0, width, halfHeight + overlap);
            renderer.setScissor(0, 0, width, halfHeight + overlap);
            renderer.setScissorTest(true);
            renderer.render(cylinderScene, cylinderCamera);

            // Disable scissor test
            renderer.setScissorTest(false);
        }

        // ========================================
        // Initialize and Start
        // ========================================

        initScene();
        initInput();
        onWindowResize(); // Set initial viewport sizes
        animate();

    </script>
</body>
</html>
